## 799p)
> 생성자에서 new를 사용하여 메모리를 대입했을 때에는, 대응하는 파괴자에서 delete를 사용하여 그 메모리를 해제해야 한다. 생성자에서 new [] 형식을 사용했다면, 파괴자에서도 delete [] 형식을 사용해야 한다.
___
## 812p)
> 클래스가 new에 의해 초기화되는 포인터들을 멤버로 가지고 있을 경우에, 포인터 자체를 복사하는 것이 아니라, 그 포인터가 지시하는 데이터를 복사하는 복사 생성자를 정의해야 한다. 이것을 ```깊은 복사(deep copy)```라 한다. 복사의 다른 한 가지 형태(멤버별 복사 또는 얕은 복사)는 포인터 값만을 복사한다. ```얕은 복사```는, 포인터가 지시하는 데이터들을 복사하기 위해 깊게(deeply)파고들지 않고, 포인터 정보만 얕게(shallowly) 살짝 들어 복한다.
___
## 818p) C++ Null Pointer
> C++98 버전에서 0은 숫자 값 ```'0'과 'Null pointer'```의 두 가지 의미가 있었다. 이 때문에 많은 리더와 컴파일러가 두 의미를 구분하는 데 매우 어려움을 겪었다. 프로그래머들은 이를 구분하기 위해서 종종 (void*)0을 사용하기도 하였다. (null pointer는 그 자체로 0이 아닌 내부 표현을 가질 수도 있다.)  
> 또 어떤 프로그래머들은 NULL을 사용하기도 하였다. 이는 null pointer를 표현하기 위하여 C 매크로에서 사용된 것이다. 그러나 이러한 일련의 방법들은 불완전한 해결 방안일 것으로 판명되었다.  
> C++11에서는 이러한 문제점을 해결하기 위하여 ```'nullptr'```라는 새로운 키워드를 제공하여 null pointer를 표시한다. 독자는 예전 방식과 마찬가지로 0을 사용하거나 지금은 유효하지 않은 기존의 다양한 코드를 사용할 수 도 있겠지만, 본서에서 제공하는 nullptr을 사용할 것을 권유하고자 한다.
> <pre><code>str = nullptr;     // c++11 null 포인터 표기</code></pre>
___
## 863p)
> 생성자가 아닌 다른 클래스 메서드에는 멤버 초기자 리스트 문법을 사용할 수 없다.
## 797p)
> static 데이터 멤버는 클래스 선언 안에서 선언되지만, 클래스 메서드 파일에서 초기화된다. 그 static 클래스 멤버가 어느 클래스에 속하는지 나타내기 위해서 초기화할 때 사용 범위 결정 연산자를 사용한다. 그러나 static 멤버가 정수형이나 열거형의 const이면 클래스 선언 자체에서 초기화할수 있다.
___
## 800p)
> StringBad의 이 설계 초안은 정확한 출력을 정의할 수 없게 만드는, 고의로 만든 결점을 가지고 있다. 예를 들어, 사용한 일부 컴파일러들은 컴파일을 완료하기도 전에 멈췄다. 그러나 세부 사항이 다르게 출력되더라도, 기본적인 문제점과 해결책(곧 설명한다)은 동일하다.
___
## 830p)
> ```get(char *, int)```의 오래된 버전들은 빈 줄을 읽었을 때 false로 평가하지 않는다. 그러한 버전들의 경우에, 빈 줄이 입력되면 문자열의 첫 번째 문자는 널 문자이다. 이 예제는 다음과 같은 코드를 사용하고 있다.
> <pre><code>if (!cin || temp[0] == '\0')       // 입력이 실패했거나 빈 줄 입력이면
>     break;                         // i를 증가시키지 않는다</code></pre>
> C++ 시스템들이 현재의 C++ 표준을 따르고 있다면, 빈 줄 입력은 if 조건문의 첫 번재 테스트에서 인식된다. 반면에 오래된 C++ 시스템에서는, 빈 줄 입력이 두 번째 테스트에서 인식된다.
___
## 832p) NULL과 0, nullptr
> ```널 포인터```는 ```0 또는 NULL```로 나타낼 수 있다. NULL은 여러 개의 헤더 파일에 0으로 정의되어 있는 기호 상수이다. C 프로그래머들은 흔히 그 값이 포인터 값이라는 사실을 잊지 않지 위해 0 대신 NULL을 사용한다. 그들은 또 널 문자를 나타낼 때에도 0 대신 '\0'을 사용한다. 이 역시 그 값이 문자라는 사실을 잊지 않기 위해서이다. 그러나 C++ 프로그래머들은 NULL 대신에 보다 간단한 0을 사용하는 것을 더 좋아하는 것처럼 보인다. 그리고 앞서 언급한 바와 같이, C++11은 ```'nullptr'키워드```를 대안으로 제시하고 있다.
___
## 797p)
> static 데이터 멤버는 클래스 선언 안에서 선언되지만, 클래스 메서드 파일에서 초기화된다. 그 static 클래스 멤버가 어느 클래스에 속하는지 나타내기 위해서 초기화할 때 사용 범위 결정 연산자를 사용한다. 그러나 static 멤버가 정수형이나 열거형의 const이면 클래스 선언 자체에서 초기화할수 있다.
___
## 800p)
> StringBad의 이 설계 초안은 정확한 출력을 정의할 수 없게 만드는, 고의로 만든 결점을 가지고 있다.  
> 예를 들어, 사용한 일부 컴파일러들은 컴파일을 완료하기도 전에 멈췄다. 그러나 세부 사항이 다르게 출력되더라도, 기본적인 문제점과 해결책(곧 설명한다)은 동일하다.
___
## 830p)
> ```get(char *, int)```의 오래된 버전들은 빈 줄을 읽었을 때 false로 평가하지 않는다. 그러한 버전들의 경우에, 빈 줄이 입력되면 문자열의 첫 번째 문자는 널 문자이다.  
> 이 예제는 다음과 같은 코드를 사용하고 있다.
> <pre><code>if (!cin || temp[0] == '\0')       // 입력이 실패했거나 빈 줄 입력이면
>     break;                         // i를 증가시키지 않는다</code></pre>
> C++ 시스템들이 현재의 C++ 표준을 따르고 있다면, 빈 줄 입력은 if 조건문의 첫 번재 테스트에서 인식된다. 반면에 오래된 C++ 시스템에서는, 빈 줄 입력이 두 번째 테스트에서 인식된다.
___
## 832p) NULL과 0, nullptr
> ```널 포인터```는 ```0 또는 NULL```로 나타낼 수 있다. NULL은 여러 개의 헤더 파일에 0으로 정의되어 있는 기호 상수이다. C 프로그래머들은 흔히 그 값이 포인터 값이라는 사실을 잊지 않지 위해 0 대신 NULL을 사용한다. 그들은 또 널 문자를 나타낼 때에도 0 대신 '\0'을 사용한다. 이 역시 그 값이 문자라는 사실을 잊지 않기 위해서이다.  
> 그러나 C++ 프로그래머들은 NULL 대신에 보다 간단한 0을 사용하는 것을 더 좋아하는 것처럼 보인다. 그리고 앞서 언급한 바와 같이, C++11은 ```'nullptr'키워드```를 대안으로 제시하고 있다.
___
## 842p) new에 의한 객체 초기화
> 일반적으로, *Class_name*이 클래스 이름이고 *value*가 *Type_name*형의 값이면, 다음과 같은 구문은
> <pre><code><i>Class_name</i> * <i>pclass = new Class_name</i>(<i>value</i>)</i>;</code></pre>
> 다음과 같은 생성자를 호출한다.
> <pre><code><i>Class_name</i>(<i>Type_name</i>)</i>;</code></pre>
> 다음과 같은 사소한 변환도 이루어질 수 있다.
> <pre><code><i>Class_name</i>(const <i>Type_name</i> &);</code></pre>
> 또한, int를 double로 변환하는 것과 같은, 원형 일치에 의해 호출되는 변환은 모호성이 없는 한 이루어질 것이다.  
> 다음과 같은 형식의 초기화는 디폴트 생성자를 호출한다.
> <pre><code><i>Class_name</i> * ptr = new <i>Class_name</i>;</code></pre>
___
## 860p) 내포된 구조체와 클래스
> 구조체, 클래스, 열거체가 어떤 클래스 안에서 선언되면, 그 클래스에 내포된다고 말하며, 그 선언은 그 클래스의 사용 범위를 가진다. 그러한 선언은 데이터 객체를 생성하지 않고, 그 클래스 안에서 내부적으로 사용할 수 있는 데이터형을 서술한다.  
> 그 선언이 클래스의 private 부분에 있으면, 선언된 그 데이터형은 그 클래스 안에서만 사용할 수 있다.  
> 그 선언이 public부분에 있으면, 선언된 그 데이터형은 사용 범위 결정 연산자를 사용하여 그 클래스 바깥에서도 사용할 수 있다.  
> 예를 들어, Node가 Queue 클래스의 public 부분에 있으면, 그 클래스의 바깥에서 Queue::Node형의 변수를 선언할 수 있다.
___
## 862p~863p) 멤버 초기자 리스트 문법
> Classy가 클래스이고, mem1, mem2, mem3가 클래스 데이터 멤버라면, 클래스 생성자는 다음과 같은 문법을 사용하여 그 데이터 멤버들을 초기화시킬 수 있다. 
> <pre><code>Classy::Classy(int n, int m) : mem1(n), mem2(0), mem3(n*m + 2)
> {
> //...
> }</code></pre>
> 이것은 mem1을 n으로, mem2를 0으로, mem3를 n*m + 2로 초기화한다. 개념적으로, 이들 초기화는 중괄호 안의 코드가 실행되기 전, 객체가 생성될 때 이루어진다.  
> 다음과 같은 사항에 주의해야 한다.  
> * 이 형식은 생성자에서만 사용할 수 있다.
> * (적어도 C++11 버전 이전에는)static이 아닌 const 데이터 멤버를 초기화하려면 이 형식을 사용해야 한다.
> * 참조 데이터 멤버를 초기화하려면 이 형식을 사용해야 한다.  
> 
> 데이터 멤버들은, 초기자 리스트에 나열된 순서가 아니라, 클래스 선언에 선언된 순서대로 초기화된다. 
___
## 863p~864p) C++11 멤버 In-Class 초기화
> C++11은 사용자로 하여금 분명한 내용에 대하여 용이하게 작업할 수 있도록 해 준다.
> <pre><code>class Classy
> {
>     int mem1 = 10;              // in-class 초기화
>     const int mem2 = 20;    // in-class 초기화
> //...
> };</code></pre>
> 이것은 생성자 내의 멤버 초기화 리스트를 사용하는 것과 동일하다.
> <pre><code>Classy:: Classy() : mem1(10), mem2(20) {...}</code></pre>
> 만약 멤버 초기화 리스트를 사용하는 생성자가 호출되지 않았다면, mem1과 mem2는 각각 10과 20으로 초기화된다. 이후 실질적인 리스트가 이런 기본 초기화 값들을 수정한다.
> <pre><code>Classy()::Classy(int n) : mem1(n) {...}</code></pre>
> 이 경우, 생성자는 mem1을 초기화하는데 n 값을 사용할 것이며 mem2는 여전히 20이 된다.
___
## 878p)
> bool을 지원하지 않는 C++ 컴파일러에서는 bool 대신 int, false 대신 0, ture 대신 1을 사용할 수 있다. 또한 cstdlib 대신 stdlib.h, ctime 대신 time.h를 사용해야 한다. 사용자가 RAND_MAX를 직접 정의해야 할지도 모른다.
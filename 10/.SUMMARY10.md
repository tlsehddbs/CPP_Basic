OOP는 프로그램이 데이터를 표현하는 방법을 강조한다. 프로그래밍 문제를 OOP적인 접근으로 해결하는 첫 단계는, 데이터를 프로그램의 인터페이스를 가지고 서술하는 것이다. 인터페이스는 데이터를사용하는 방법을 말한다. 그 다음은 그 인터페이스를 구현하는 클래스를 설계한다. 일반저긍로, private 데이터 멤버들이 정보를 저장하고, 메서드라 부르는 public 멤버 함수들이 유일한 데이터 접근 방법을 제공한다. 클래스는 데이터와 메서드들을 하나의 패키지로 결합한다. private 기능이 데이터 은닉을 실현한다.

일반적으로, 클래스 선언을 두 부분으로 나누어, 각 부분을 독립된 파일에 저장한다. 에서드들이 원형으로 표현되어 있는 클래스 선언을 하나의 헤더 파일에 저장한다. 그 멤버 함수들을 정의하는 소스 코드는 다른 하나의 메서드 파일에 저장한다. 이러한 접근 방식은 인터페이스와 세부 구현을 분리시키는 것이다. 대체로, 클래스를 사용하기 위해서는 그 클래스의 public 인터페이스만 알면 된다. 물론 사용자가 세부 구현을 들여다볼 수는 있다(컴파일된 현태로 제공되지 않을 경우에). 그러나 어떤 특정한 값이 int형으로 저장된다는 것과 같은, 세부적인 구현에 사용자 프로그램이 종속되면 안 된다. 프로그램과 클래스가, 인터페이스를 정의하고 있는 메서드들을 통해서만 서로 소통하는 한, 미처 생각하지 못한 엉뚱한 문제를 행여나 일으키지 않을까 걱정하지 않고 프로그램과 클래스를 따로따로 개선할 수 있다.

클래스는 사용자 정의 데이터형이다. 그리고 객체는 클래스의 구체적인 하나의 사례(instance)이다. 그것은 객체가 그 데이터형의 변수, 또는 클래스 서술에 따라 new에 의해 대입된 메모리와같은, 변수 등가물이라는 것을 뜻한다. C++는 사용자 정의 데이터형을 표준 데이터형과 최대한 비슷하게 만들려고 한다. 그렇기 때문에 객체, 객체를 지시하는 포인터, 객체들의 배열을 선언할 수 있다. 객체를 매개변수로 전달할 수 있고, 함수의 리턴값으로 사용할 수 있으며, 하나의 객체를 같은 데이터형의 다른 객체에 대입할 수도 있다. 생성자 메서드를 제공하면, 객체들을 생성하면서 동시에 그들을 초기화할 수 있다. 파괴자 메서드를 제공하면, 객체의 수명이 다했을 때 프로그램이 파괴자 메서드를 실행한다.

객체들은 클래스 선언의 데이터 부분에 대한 사본을 하나씩 갖지만, 클래스 메서드들은 공유한다. mr_object가 특정 객체의 이름이고, try_me()가 멤버 함수라면, mr_object.try_me()와 같이 도트 멤버 연산자를 사용하여 그 멤버 함수를 호출한다. 이 함수 호출을 OOP적으로 표현하면, mr_object 객체에 try_me() 메시지를 보내는 것이다. try_me() 메서드에 사용되는 클래스 데이터 멤버들은 mr_object에 적용된다. 마찬가지로, i_object.try_me() 함수 호출은 i_object 객체의 데이터 멤버들에 접근한다.

하나의 멤버 함수를 하나 이상의 객체에 적용하기 위해서, 그 메서드에 제2의 객체를 매개변수로 전달할 수 있다. 메서드가 그것을 호출한 객체를 명시적으로 참조해야 한다면, this 포인터를 사용할 수 있다. this 포인터는 호출한 객체의 주소로 설정한다. 즉, *this는 그 객체 자체의 대용 이름이다. 

클래스는 ADT와 잘 어울린다. public 멤버 함수 인터페이스는 ADT에 의해 서술되는 서비스를 제공한다. 클래스의 private 부분과, 클래스 메서드들에 해당하는 코드는, 그 클래스의 클라이언트에게 보이지 않는 세부 구현을 제공한다.

C++는 공통적인 프로그래밍 문제에 대한 해결책과, 그 밖의 다른 많은 문제들을 간소화할 수 있는 도구들을 지원하는 강력한 라이브러리들을 포함하고 있다. tring 클래스는 문자열을 객체로 다룰 수 있는 편리한 수단을 제공한다. string 클래스는 자동 메모리 관리 기능과, 문자열에 사용할 수 있는 다양한 메서드들과 함수들을 제공한다. 예를 들면, 이 메서드들과 함수들을 사용하여 문자열들을 하나로 결합하고, 한 문자열을 다른 문자열 안에 삽입하고, 문자열을 뒤집고, 문자열 안에서 어떤 문자나 부분문자열을 검색하고, 문자열 입출력 연산을 수행할 수 있다. 

auto_ptr이나 C++11의 shared_ptr 및 unipue_ptr과 같은 스마트 포인터 템플릿은 new에 의해 대입된 메모리를 쉽게 관리할 수 있도록 해 준다. new가 리턴하는 주소를 저장하기 위해서 일반 포인터 대신 이러한 스마트 포인터 테플릿을 사용하게 되면, 나중에 반드시 delete 연산자를 사용해야 한다는 사실을 기억하지 않아도 된다. 스마트 포인터 객체가 종료되면 파괴자가 자동으로 delete연산자를 호출하기 때문이다.  

STL은 일반화 프로그래밍 패러다임에 기초하여 일관되게 설계된 컨테이너 클래스 템플릿, 이터레이터 클래스 템플릿, 함수 객체 템플릿, 알고리즘 함수 템플릿 들을 한데 모아 놓은 것이다. 알고리즘을 저장되는 객체형으로 일반화하기 위해 템플릿을 사용하고, 알고리즘을 컨테이너형으로 일반화하기 위해 이터레이터 인터페이스를 사용한다. 이터레이터는 포인터를 일반화한 것이다. 

STL은 '개념'이라는 용어를 사용하여 요구 사항 들을 서술한다. 예를 들러, 전방 이터레이터(forward iterator) 개념에는, 읽기와 쓰기를 위해 전방 이터레이터 객체가 내용 참조될 수 있고, 증가될 수 있다는 요구 사항이 포함된다. 개념을 실제로 구현하는 것을 개념을 모델링(modeling)한다고 한다. 예를 들어,전방 이터레이터 개념은 보통의 포인터에 의해 또는 링크드 리스트를 훑을 수 있도록 설계된 객체에 의해 모델링될 수 있다. 다른 개념들에 기초를 두고 있는 개념을 '개량(relinement)'이라 한다. 예를 들어, 양방향(bidirectional)이터레이터는 전방 이터레이터 개념의 개량이다.

vector나set과 같은 컨테이너 클래스들은 컨테이너, 시퀀스, 결합성 컨테이너와 같은 컨테이너 개념의 모델이다. STL은 vector, deque, list, set, miltiset, map, multimap, bitset 등과 같은 컨테이너 클래스 템플릿들을 정의한다. 또한 queue, priority_queue, stack과 같은 어댑터 클래스 템플릿들을 정의한다. 이러한 클래스들은 그 어댑타 클래스 템플릿의 이름이 의미하는 특별한 인터페이스를 제공하기 위해, 기초를 이루는 컨테이너 클래스를 개조할 수 있다(adaptable).따라서 stack이 기본적으로 vector에 기초를 두고 있더라도, 스택의 꼭대기에서만 삽입과 삭제가 이루어지도록 개조할 수 있다. C++11에서는 forward_list, unordered_set, unordered_multiset, unordered_map,그리고 unordered_multimap으ㅣ 다섯 가지가 주어진다. 

어떤 알고리즘은컨테이너 클래스 메서드로 표현된다. 그러나 대부분의 알고리즘은 멤버가 아닌 보통의 함수들로 표현된다. 이것은 이터레이터를 컴테이터와 알고리즘 간의 인터페이스로 사용함으로써 가능해진다. 이와 같은 접근의 첫 번째 장점은, 각 컨테이너마다 별도의 버전을 만들 필요 없이, 하나의for_each()나 copy()만 있으면 충분하다는 것이다. 두 번째 장점은 STL 알고리즘들을 보통의 배열, string객체와 같은 STL이 아닌 컨테이너들, STL 이터레이터나 컨테이너와 잘 어울리도록 설계된 모든 클래스들에 사용할 수 있다는 것이다. 

컨테이너와 알고리즘은 그들이 제공하거나 요구하는 이터레이터형에 따라 그 특징이 부여된다. 따라서 컨테이너가 알고리즘의 요구 사랑을 지원하는 이터레이터 개념을 가지고 있는 지 확인해야 한다. 예를 들어, for_each() 알고리즘은 모든 STL 컨테이너 클래스형들의 최소한의 요구 사항인, 입력 이터레이터를 사용한다. 그러나 sort() 알고리즘은 임의 접근 이터레이터를 요구한다. 임의 접근 이터레이터는 모든 컨테이너 클래스들이 요구하는 것은 아니다. 컨테이너 클래스는 특정 알고리즘의 요구 사항이 충족되지 않는다면 특수화된 메서드를 하나의 옵션으로 제공할 수 있다. 예를 들어, list 클래스는 양방향 이터레이터에 기초를 둔 ort() 메서드를 가지고 있다. 그래서 보통의 함수 대신 그 메서드를 사용할 수 있다.


STL은 또한 () 연산자가 오버로딩 된(즉, operator() () 메서드가 정의된) 클래스인, 함수 객체(function object)또는 펑크터(functor)를 제공한다. 그러한 클래스들의 객체는 함수 표기를 사용함으로써 호출될 수 있따. 그러나 다른 정보도 전달할 수 있다. 예를 들어, 순응성(adaptable) 펑크터는, 그 펑크터를 위한 매개변수형과 리턴형을 나타내는 typerdef 구문을 가지고 있다. 함수 어댑터와 같은 다른 성분들이 이 정보를 사용할 수 있다. 

공통적인 컨테이너형들을 표현하고, 효율적인 알고리즘으로 구현된 다양한 공통적인 연산들을 모두 일반화한 방식으로 제공함으로써, STL은 코드의 재활용을 적극적으로 지원한다. STL이 제공하는 도구들로 프로그래밍 문제를 직접 해결할 수도 있고, 원하는 해결책을 구성하는 기본 요소로 사용할 수도 있다. 

complex와 valarry 템플릿 클래스는 복소수와 배열을 위한 수치 연산을 지원한다. 

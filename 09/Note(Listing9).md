## 563p~564p) 헤더 파일의 관리
> 헤더 파일을 어떤 파일에 포함시킬 때에는 단 한 번만 포함시켜야 한다. 이것을 기억하는 일은 식은 죽 먹기라고 생각할지도 모르지만, 헤더 파일을 여러 번 포함시키는 실수를 저지르기 쉽다. 예를 들면, 다른 헤더 파일을 이미 포함하고 있는 헤더 파일을 멋모르고 사용할 수 있다. C와 C++에서 헤더 파일을이미 포함시키는 실수를 피하기 위하여 사용하는 표준 기법이 있다. 전처리기 지시자 ```#ifndef(if not defined를 의미한다)```를 사용하는 것이다. 다음과 같은 코드 단편은
> <pre><code>#ifndef COORDIN_H_
> ...
> #endif</code></pre>
> COORDIN_H_라는 이름이 전처리기 지시자 ```#define```에 의해 정의되어 있지 않은 경우에만, ```#ifndef```와 ```#endif``` 사이에 있는 구문들을 처리하라는 뜻이다.   
> 일반적으로 우리는 #define을 사용하여 다음과 같이 기호 상수를 정의한다.
> <pre><code>#define MAXIMUM 4096</code></pre>
> 그러나 다음과 같이 #define에 간단히 이름만 사용해도, 그 이름이 정의된다는 것을 컴파일러에게 알릴 수 있다. 
> <pre><code>#define COORDIN_H_</code></pre>
> Listing 9.1이 사용하는 테크닉은 #ifndef 안에 include 파일 내용을 넣은 것이다
> <pre><code>#ifndef COORDIN_H_
> #define COORDIN_H_
> // 포함시킬 include 파일의 내용을 여기에 넣는다
> #endif</code></pre>
> 컴파일러가 이 파일을 처음 만났을 때, COORDIN_H_라는 이름이 정의되어 있으면 안 된다.(다른 곳에서 좀처럼 사용할 것 같지 않은 이름으로 만들기 위해, 밑줄 문자를 사용하고, include 파일의 이름을 본떠서 그 이름을 만들었다.) COORDIN_H_이 정의되어 있지 않을 경우에만, 컴파일러는 ```#ifndef```와 ```#endif``` 사이에 있는 구문들을 보게 된다. 그것이 우리가 원하는 것이다. 그 구문들을 보는 과정에서, 컴파일러는 COORDIN_H_를 정의하고 있는 행을 읽는다.  
> 만일 그 이후에 컴파일러가 같은 파일 안에서 coordin.h가 다시 한 번 포함된 것을 발견하면, 컴파일러는 즉시 #endif 바로 뒤에 있는 행으로 건너뛴다. 이 기법은 컴파일러가 한 파일을 두 번 포함시키는 것을 막지는 못한다. 그 대신, 처음으로 포함시킨 것을 제외한 나머지를 컴파일러가 무시하게 만든다. C와 C++의 대부분의 표준 헤더 파일들이 이 보호 기법을 사용한다. 그렇지 않으면 하나의 파일에 두 번 정의된 동일한 구조를 얻게 될 수도 있으며 그것이 컴파일 에러를 유발시킬 것이다. 
___
## 566p) 실전 프로그래밍 : 다중 라이브러리 링크
> C++ 표준은 각각의 컴파일러 설계자가 ```이름 장식```이나 이름 ```맹글링```(8장, "함수의 활용"에 나오는 실전 프로그래밍 노트 "[이름 장식이란 무엇인가?](https://github.com/tlsehddbs/CPP_Basic/blob/main/08/Note(Listing8).md, "Note(Listing8.md")"를 보라)을 컴파일러에 필요한 만큼 구현할 수 있도록 허용한다. 그러므로 서로 다른 컴파일러로 만든 이진화 모듈(목적 코드 파일)은 서로 잘 링크되지 않는다.  
> 즉, 서로 다른 컴파일러들은 하나의 동일한 함수에 대해서 서로 다르게 장식한 이름을 만들어 낸다. 바로 이 이름의 차이가, 어떤 한 컴파일러가 만든 함수 호출을 다른 컴파일러가 만든 함수 정의에 대응시키려는 **링커**의 작업을 방해한다. 컴파일된 모듈을 링크시켜야 할 때에는, 각각의 목적 파일이나 라이브러리들이 같은 컴파일러로 만들어진 것인지 반드시 확인해야 한다. 소스 코드를 가지고 있다면, 자기가 사용하는 컴파일러로 만들어진 것인지 반드시 확인해야 한다. 소스 코드를 가지고 있다면, 자기가 사용하는 컴파일러를 사용하여 그 소스 코드를 다시 컴파일함으로써 이러한 링크 에러 문제를 해결할 수 있다.
___
## 572p) C++11에서의 auto에 대한 변화
> C++11에서 키워드 ```auto```는 이미 이 책의 3장, 7장, 8장에서 살펴보았듯 자동형을 연역하는데에 사용된다. 그러나 C++의 이전 버전과 C는 전혀 다른 의미를 지닌다. 이를 통해서 명시적으로 변수는 자동 저장소로 인식되어 왔다.
> <pre><code>int frrob(int n)
> {
>     auto float ford;      // ford has automatic atorage
>     ...
> }</code></pre>
> auto 키워드는 자동 변수에만 사용할 수 있기 때문에, 대부분의 프로그래머들은 ```auto 키워드```에 대해 별로 신경을 쓰지 않는다. auto 키워드는 간혹 코드를 명확하게 읽을 수 있도록 하기 위해 사용되지만, C++11에서는 이렇게 사용되는 것이 더 이상 유효하지 않다. 표준을 준비하는 사람들은 새로운 키워드를 제공하는 것을 꺼려하는데, 이는 새로운 키워드를 제공하는 행위로 인해 그 단어를 다른 용도로 사용하는 기본의 코드를 더 이상 유효하지 않게 만들 수도 있기 때문이다. 이러한 경우, auto 키워드를 과거 방식대로 사용하는 경우는 매우 드물다. 오히려 auto 키워드의 목적을 다시 설정하는 것이 새로운 키워드를 소개하는 것보다 낫다.
___
## 575p) 
> 클래식 K&R C는 자동 배열과 자동 구조체를 초기화하는 것은 허용하지 않지만, 정적 배열과 정적 구조체를 초기화하는 것은 허용한다. 그러나 ANSI C와 C++에서는 두 가지 경우를 모두 초기화할 수 있다. 그러나 일부 구형 C++ 번역기는 ANSI C 규정을 완전하게 따르지 않는 C 컴파일러를 이용한다. 따라서 만약 사용자가 그러한 C++ 번역기를 사용한다면, 배열 구조체를 초기화할 때 세 가지 유형으로 주어지는 정적 변수 중에서 어느 하나를 사용할 필요가 있다.
___
## 583p) 전역과 지역(global과 local)
> 전역 변수를 사용할 것인지 지역 변수를 사용할 것인지 선택해야 한다면, 어느 것을 사용해야 할까?  
> 언뜻 보기에, 전역 변수에는 모든 함수가 접근할 수 있고, 매개변수를 전달할 필요도 없기 때문에 전역 변수에 당장 호감이 간다. 그러나 이처럼 접근이 쉬운 것이 오히려 프로그램의 신뢰성을 떨어뜨린다. 경험에 의하면, **데이터에 대한 불필요한 접근을 잘 막으면 막을수록 데이터의 무결성이 보전된다.** 대부분의 경우에, 데이터를 무차별적으로 전역 변수로 만들기보다는, 지역 변수로 만들어 꼭 필요한 함수에만 데이터를 전달하는 것이 좋다. 곧 알게 되겠지만 OOP에서는 이러한 데이터 격리 개념을 한 단계 더 발전시킨다.  
> 그러나 전역 변수가 유용할 때도 있다. 예를 들어, 월 이름의 배열이나 원소 원자량의 배열처럼 여러 함수가 공통으로 사용하는 데이터 블록을 만들 수 있다. ```const 키워드```를 사용하면 상수 데이터가 변경되지 않도록 할 수 있기 때문에, 전역 변수는 특히 상수 데이터를 나타내는 데 유용하다. 
> <pre><code>const char * const months[12] = 
> {
>     "January", "February", "March", "April", " May",
>     "June", "July", "August", "September", "October", 
>     "November", "December"
> };</code></pre>
> 이 예에서, 첫 번째 const는 그 문자열들이 변경되는 것을 막고, 두 번째 const는 배열에 들어 있는 각각의 포인터가 최초에 지시한 문자열을 계속 지시하도록 만든다.
___
## 585p)
> 다중 파일 프로그램에서 단 하나의 파일에 하나의 이름으로 외부 변수 선언이 가능하다. 다른 파일에서 그 변수를 사용하기 위해서는 ```extern 선언```을 해야만 한다.
___
## 594p) C++는 어디에서 함수를 찾을까?
> 프로그램의 특정한 파일에 들어 있는 함수를 호출한다고 가정해 보자. C++는 어디에서 그 함수 정의를 찾아낼까? 그 파일에 들어 있는 함수 원형이 그 함수가 정적이라고 알려 준다면, 컴파일러는 그 함수를 그 파일 안에서만 찾는다. 그렇지 않은 경우에, **컴파일러(링커도 포함하여)**는 프로그램을 구성하는 모든 파일에서 그 함수를 찾는다.  
> 외부 변수에 대해서 단 하나의 정의만 있어야 하기 때문에, 두 개의 함수 정의를 발견하면 컴파일러는 에러 메시지를 출력한다. 모든 프로그램 파일에서 어떠한 함수 정의도 찾아내지 못하면, 이번에는 라이브러리를 검사한다. 이 말은, 라이브러리 함수와 같은 이름을 가지는 함수를 정의했을 경우에, 컴파일러는 라이브러리 버전 대신 사용자 버전을 사용한다는 것을 의마한다. (그러나 C++는 표준 라이브러리 함수의 이름은 특별히 예약해 둔다. 그래서 그들을 다시 사용하면 안 된다.) 일부 컴파일러-링커는 어느 라이브러리를 찾을 것인지를 명시적으로 지시해 줄 것을 요구한다.
___
## 596p)
> 일반적으로 new로 대입한 메모리는 프로그램이 종료할 때 해제된다. 그러나 항상 그런 것은 아니다. 예를 들어, 다소 취약한 운영체제에서 큰 메모리 블록을 요청하면, 프로그램이 종료될 대 자동으로 삭제되지 않은 블록이 생길 수 있다. 최선의 방법은, ```new```로 대입한 메모리를 ```delete```를 사용하여 해제하는 것이다.
___
## 611p)
> 이름 공간과 선언 영역이 둘 다 같은 이름을 정의하고 있다고 가정하자. ```using 선언```을 사용하여 그 이름 공간에 있는 이름을 선언 영역으로 불러오려고 시도하면, 두 이름이 충돌하여 에러가 발생한다. ```using 지시자```를 사용하여 그 이름 공간에 있는 이름을 선언 영역에 불러오면, 그 이름의 지역 버전이 이름 공간 버전의 앞을 가린다.
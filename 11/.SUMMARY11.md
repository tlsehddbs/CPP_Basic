이 장에서는 클래스 정의를 정의하고 사용하는 것에 관련이 많은 중요한 사항을 다루었다. 이 장에서 설명한 어떤 주제는 독자가 충분한 경험을 얻기 전까지는 그저 막연한 것으로 남아 있을 수도 있다.

일반적으로, **클래스의 private 멤버에 접근하는 유일한 방법은 클래스 메서드를 이용하는 것**이다. C++는 ```프렌드 함수```라는 것을 통해 이 제약을 완화시키고 있다. 어떤 함수를 프렌드 함수로 선언하기 위해서는, 그 함수를 클래스 선언 안에 선언하고, 그 선언 앞에 ```friend 키워드```를 붙인다.

특정 연산자들을 특정 클래스에 관련시키는 방법을 서술하는 특별한 연산자 함수들을 정의함으로써, **C++는 오버로딩을 연산자에까지 확장**한다. 연산자 함수는 클래스 멤버 함수 또는 프렌드 함수가 될 수 있다. (연산자 중에 몇 가지는 클래스 멤버 함수만 될 수 있다.) C++는 직접 함수를 호출함으로써 또는 오버로딩된 연산자를 일반적인 문법으로 사용함으로써 그 연산자 함수를 호출할 수 있다. 연산자 op와 관련된 연산자 함수는 다음의 형식을 취한다.
<pre><code>operatorop(<i>argument-list</i>)</code></pre>
여기서 *argument-list*는 그 연산자에 대한 피연산자를 나타낸다. 연산자 함수가 클래스 멤버 함수라면, 첫 번재 피연산자는 반드시 호출한 객체가 되어야 하고, 그것은 *argument-list*의 일부가 될 수 없다. 예를 들어, 이 장에서 우리는 Vector 클래스에 대한 operator+() 멤버 함수를 정의함으로써 덧셈을 오버로딩하였다. up, right, result가 3개의 벡터라면, 벡터 덧셈을 호출하기 위해 다음과 같은 형식 중 어느 구문이나 사용할 수 있다.
<pre><code>result = up.operator+(right);
result = up + right;</code></pre>
두 번째 형식에서, up과 right가 Vector형이라는 사실이 Vector 덧셈 정의를 사용해야 한다는 것을 말해 준다. 

연산자 함수가 멤버 함수일 때, 첫 번재 피연산자는 그 함수를 호출한 객체이다. 예를 들어, 앞의 예에서는 up 객체가 호출한 객체이다. 첫 번째 피연산자가 클래스 객체가 아닌것으로 정의하고 싶으면, 프렌드 함수를 사용해야 한다. 프렌드 함수 정의에는 원하는 순서대로 피연산자를 전달할 수 있다. 

연산자 오버로딩 중에서 가장 유용한 것 중의 하나는, << 연산자를 정의하여 cout과 함께 사용함으로써 어떤 객체의 내용을 출력하는 것이다. ostream 객체가 첫 번째 피연산자가 되게 하려면, 이 연산자 함수를 프렌드로 정의해야 한다. 오버로딩된 << 연산자가 그 자체와 연결되게 하려면 ostream &형을 리턴형으로 사용해야 한다. 다음은 이와 같은 요구 사항을 만족시키는 일반적인 형식이다.
<pre><code>ostream & operator<<(ostream & os, const c_name & obj)
{
    os << ... ;     // 객체의 내용을 출력한다
    return os;
}</code></pre>
그러나 그 클래스가 출력하기 원하는 데이터 멤버들의 값을 리턴하는 메서드들을 가지고 있다면, operator<<()에 직접 접근하는 대신 그러한 메서드들을 사용할 수 있다. 그러한 경우에는 이 함수가 프렌드일 필요가 없다. (프렌드이면 안 된다.)

C++는 클래스형으로 또는 클래스형에서 다른 데이터형으로 변환하는 것을 허용한다. 첫째, 하나의 매개변수를 사용하는 클래스 생성자는 변환 함수처럼 동작하여, 매개변수 데이터형의 어떤 값을 클래스형으로 변환한다. 매개변수 데이터형의 어떤 값을 객체에 대입하면 C++는 이 생성자를 자동으로 호출한다. 예를 들어, 하나의 char *형 값을 매개변수로 사용하는 생성자가 String 클래스 안에 정의되어 있다고 가정하자. 이제 bean이 String 객체라면, 다음과 같은 구문을 사용할 수 있다.
<pre><code>bean = "pinto";      // char *형을 String형으로 변환한다</code></pre>
그러나 생성자 선언 앞에 키워드 explicit를 붙이면, 그 생성자는 명시적 변환을 위해서만 사용할 수 있다. 
<pre><code>bean = String("pinto");      // char *형을 String형으로 명시적으로 변환</code></pre>
클래스를 다른 데이터형으로 변환하려면, 변환 함수를 정의하고 변환 방법에 대한 지시를 제공하야 한다. 변환 함수는 멤버 함수여야 한다. *typename*형으로 변환하기를 원한다면 함수의 원형이 다음과 같아야 한다.
<pre><code>operator <i>typename</i>();</code></pre>
변환 함수는 리턴형을 선언하지 않는다. 그리고 어떠한 매개변수도 사용하지 않는다. 그러나 (리턴형을 선언하지 않는데도 불구하고) 변환된 값을 리턴한다. 예를 들어, Vector형을 double형으로 변환하는 함수의 형식은 다음과 같을 것이다. 
<pre><code>Vector::operator double()
{
    ...
    return a_double_value;
}</code></pre>
경험에 따르면, 그러한 암시적 변환 함수는 되도록 사용하지 않는 것이 바람직하다. 클래스의 사용은 단순한 C스타일의 구조체보다 더 많은 주의를 기울여야 한다. 그 보답으로 클래스는 프로그래머를 위해 많은 일을 해 준다.
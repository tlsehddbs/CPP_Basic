## 730p) 프렌드는 OOP에 어울리지 않는다?
> 언뜻 보면 멤버가 아닌 함수들이 private 데이터에 접근하는 것을 허용하기 때문에, 프렌드가 데이터 은닉이라는 OOP의 철학을 위반하고 있는 것처럼 보인다. 그러나 그것은 너무 좁은 견해이다. 그렇게 생각하지 말고, 프렌트 함수들을 클래스를 위한 확장 인터페이스의 일부라고 생각해야 한다. 개념상으로 보았을 대, double형 값에 Time 값을 곱하는 것은, Time 값에 double형 값을 곱하는 것과 같다. 전자가 프렌드 함수를 요구하고 후자가 멤버 함수를 요구하는 것은, 개념상에 차이가 있기 때문이 아니라 C++의 문법 때문이다. 프렌드 함수와 클래스 메서드를 둘 다 사용하면, 어느 연산이든지 동일한 사용자 인터페이스로 표현할 수 있다. 또한, 클래스 선언만이 어느 함수가 프렌드 함수인지를 결정할 수 있고, 그렇게 함으로써 클래스 선언은 private 데이터ㄹ에 접근하는 함수들을 여전히 통제할 수 있다. 요약하면, 클래스 메서드와 프렌드는 단순히 클래스 인터페이스를 나타내는 두 개의 서로 다른 매커니즘이다. 
___
## 732p) 프렌드인가 아닌가?
> 새로 개정된 Time 클래스 선언은 operator<<() 함수를 Time 클래스에 대한 프렌드 함수로 만든다. 이 함수는 ostream 클래스와 불화를 일으키지 않지만, ostream 클래스에 대해서는 프렌드가 아니다. operator<<() 함수는, 하나의 ostream 매개변수와 하나의 Time 매개변수를 요구한다. 그래서 마치 이 함수가 두 클래스 모두에 대해 프렌드인 것처럼 보인다. 그러나 그 함수의 코드를 들여다보면, 그 함수가 Time 객체에 대해서는 개별적인 멤버들에 접근하지만, ostream 객체는 하나의 덩어리로 사용한다는 것을 알 수 있다. operator<<()이 Time 객체의 private 멤버들에 직접 접근할 필요가 없기 때문에, 그 함수가 ostream 클래스에 대해 프렌드일 필요는 없다. 그것은 또한 사용자가 ostream 정의를 어설프게 건드릴 필요가 없다는 것을 뜻한다. 
___
## 733p) 뭐라고? ostream 클래스의 또 다른 객체들에 대해서는 모른다고?
> 또 다른 ostream 객체는 cerr로서 출력을 표준 에러 stream에 전송하는데 이것이 디스플레이이다. 그러나, Unix, Linux, 그리고 윈도우 검색 명령 환경하에서는 그 표준 에러 stream을 파일로 다시 재지정할 수 있다. (또 다른 ostream 객체 중 하나인 cerr은 출력을 표준 에러 스트림으로 전송하는데, 그 기본 값은 디스플레이이다. 그러나 Unix, Linux, 그리고 윈도우 명령줄 환경에서는 표준 에러 스트림을 파일로 다시 재지정할 수 있다.) 그리고, 6장 "분기 구문과 논리 연산자"에서 출력을 파일로 보낼 수 있는, ofstream 객체를 소개한 사실을 기억하라. 상속이라는 마술을 통해서(13장, "클래스의 상속" 참조), ofstream 객체들은 ostream 메서드를 사용할 수 있다. 그러므로 Time 데이터를 화면이나 파일에 출력할 수 있도록 하기 위해 operator<<() 정의를 사용할 수 있다. cout 대신에 적당히 초기화된 ofstream 객체를 첫 번째 매개변수로 전달하면 된다. 
___
## 740p)
> 오버로딩 연산자 함수의 멤버가 아닌 버전은, 연산자가 요구하는 수만큼의 형식 매개변수를 요구한다. 같은 연산자 함수의 멤버 버전은, 하나의 피연산자가 암시적으로 호출한 객체로 전달되기 때문에, 매개변수를 하나 적게 요구한다.
___
## 741p~742p) 벡터
> 당신이 만약 달콤한 꿀이 가득한 꽃밭을 발견한 한 마리 꿀벌이라면, 곧장 동료들이 있는 곳으로 날아가 120야드 떨어진 곳에 꿀이 있다는 사실을 알릴 것이다. 이때 다른 꿀벌들은 "정보가 충분하지 않다. 방향이 어디야?"라고 물을 것이다. 그러면 당신은 "태양에서 북쪽으로 30도 방향이야!"라고 말할 것이다. 이처럼 방향과 거리를 함께 말해야만 동료들이 그 꽃밭을 향하여 날아갈 수 있을 것이다. 즉, 꿀벌들은 본능적으로 벡터를 알고 있다. 많은 물리량들이 크기와 방향을 함께 가지고 있다. 예를 들어, 물체를 미는 결과는, 그 물체에 가하는 힘의 크기와 뱡향에 달려 있다. 컴퓨터 화면에서 객체를 다른 위치로 옮기는 것도 거리와 방향을 함께 고려해야 한다. 벡터를 사용함으로써 이 문제를 쉽게 해결할 수 있자. 예를 들어, 화면에서 객체를 다른 위치로 옮기는 것을, 출발지에서 도착지까지의 벡터를 나타내는 화살표를 그려서 설명할 수 있다.  
> 이때 벡터의 길이는 거리가 되고, 이것은 출발지에서 도착지까지 얼마나 떨어져 있는가를 나타낸다. 화살표의 방향은 그 벡터의 방향이다.(그림 11.1을 보라.) 그와 같이 위치 변화를 나타내는 벡터를 변위 벡터(displacement vector)라 한다.
> *(그림 11.1추가)*  
> 당신이 맘모스 사냥꾼이라고 가정하자. 지금 복서쪽으로 14.1km 떨어진 곳에 맘모스 무리가 있다는 보고를 받았다. 그러나 남동풍 때문에 남동쪽에서 그 맘모스 무리에 젖ㅂ근하는 것이 쉽지가 않다. 그래서 서쪽으로 10km를 간 다음, 다시 북쪽으로 10km를 가서 맘모스 무리에 접근하기로 했다. 결합된 이 위치 벡터는 북서쪽을 지시하는 14.1km 벡터와 동일한 위치를 나타낸다. 맘모스 사냥꾼인 당신은 벡터를 어떻게 더하는지 알고 있어야 한다.  
> 두 벡터를 더하는 것은 간단한 기하 문제이다. 우선 하나의 벡터를 그린 다음, 첫 번째 벡터의 화살표 끝을 시작점으로 삼아 두 번째 벡터를 그린다. 마지막으로 첫 번째 벡터의 시작점에서 두 번째 벡터의 끝점을 잇는다. 새로 만들어지는 세 번째 벡터가 처음 두 벡터의 합을 나타낸다. (그림 11.2를 보라.) 이때 세 번째 벡터의 길이는 처음 두 벡터의 길이를 합한 것보다 작을 수 있다. 
> *그림 11.2추가)*
___
## 753p) 다중 표기 형식과 클래스
> 동등하지만 다른 표기 형식을 사용하는 물리량은 아주 흔하다. 예를 들면, 휘발유 소비량을 미국에서는 갤런당 마일 수로 나타내고, 유럽에서는 100 킬로미터당 리터 수로 나타낸다. 하나의 수를 문자열 형식으로 나타낼 수 있고, 수치 형식으로 나타낼 수도 있다. 또한 지능을 IQ로 나타낼 수도 있고, 킬로터키(kiloturkey)로 나타낼 수도 있다. 클래스는 어떤 것이 지니고 있는 서로 다른 측면과 서로 다른 표기 형식을 하나의 객체 안에 넣는 것을 허용한다. 첫째, 서로 다른 표기 형식을 하나의 객체에 저장할 수 있다. 둘째, 하나의 표기 형식으로 값을 대입하면, 다른 표기 형식에도 값이 자동으로 대입되는 클래스 함수를 만들 수 있다. 예를 들어, Vector 클래스의 생성자에 제3의 매개변수로 'r'를 전달하면, x와 y 멤버가 전달된 함수 매개변수로 설정된다. 그와 동시에 생성자는 mag와 ang 멤버도 설정한다. 또한, 단일 표기 형식을 저장할 수도 있고, 여타 아른 쵸기 방식들을 가능케 하는 방법을 사용할 수도 있다. 클래스는 이러한 변환을 내부적으로 처리함으로써, 어떤 수량을 다룰 때 표기 형식이 아니라 본질적인 의미에서만 집중하면 되므로 편리하다.
___
## 757p)
> 연산자 오버로딩은 함수를 통해서 구현되기 때문에, 각각의 연산자 함수가 서로 구별되는 시그내처를 사용하고, C++에 내장된 해당 연산자가 요구하는 개수와 동일한 개수의 피연산자를 요구한다면, 같은 연산자 함수를 여러 번 오버로딩할 수 있다. 
___
## 767p)
> 하나의 매개변수를 사용하는 생성자는, 그 매개변수의 데이터형을 클래스형으로 변환하는 것을 정의한다. 그 생성자가 키워드 ```explicit```로 제한된 경우에는, **명시적 데이터형 변환만 할 수 있다**. 그렇지 않은 경우에는 암시적 데이터형 변환도 할 수 있다. 
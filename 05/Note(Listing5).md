## 240p)
> C++ 표현식은 값이나, 값과 연산자의 조합이다. C++의 모든 표현식은 하나의 값을 가진다.
___
## 244p)
> 이 리스트는 long long 형을 사용한 것이다. 만일, 시스템이 long long 형을 지원하지 않는다면 double형을 사용할 수 있다. 그러나, 정수형 포맷을 사용하는 것이 숫자가 어떻게 커지는지를 잘 보여 줄 수 있다.
___
## 252p)
> 포인터를 증가시키거나 감소시키는 것은 포인터 연산 규칙을 따른다. 그러므로 pt가 배열의 첫 번째 원소를 지시하는 포인터라면, ++pt는 pt가 두 번재 원소를 지시하게 만든다.
___
## 273p) 잘못된 구두점
> for 루프와 while 루트는 소괄호로 둘러싸인 표현식 뒤에 단일 구문으로 이루어진 루프 몸체를 가진다. 앞에서도 보았듯이, 이 단일 구문은 여러 개의 구문이 들어 있는 블록일 수도 있다. 블록을 정의하는 것은 들여쓰기가 아니라 한 쌍의 중괄호라는 사실을 잊으면 안 된다. 예를 들어, 다음과 같은 루프를 살펴보자.
> <pre><code>i = 0;
> while (name[i] != '\0')
>     cout << name[i] << endl;
>     i++;
> cout << "종료\n";</code></pre>
> 들여쓰기를 한 것으로 미루어 보아 이 코드를 작성한 사람은 i++; 구문을 루프 몸체에 포함시키려 했다는 것을 알 수 있다. 그러나 중괄호가 없으므로 컴파일러는 첫 번째 cout 구문만을 루프 몸체로 인식한다. 결과적으로 배열의 첫 번재 원소만을 무한정 출력하게 된다. i++; 구문은 루프에 속해 있지 않으므로 프로그램은 이 구문에 결코 도달할 수 없다.  
> 다음 예제는 또 다른 에러 가능성을 보여 준다.
> <pre><code>i = 0;
> while (name[i] != '\0');      // 세미콜론이 문제를 일으킨다
> {
>     cout << name[i] << endl;
>     i++;
> }
> cout << "종료\n";</code></pre>
> 이번에는 한 쌍의 중괄호를 제대로 넣었다. 그러나 필요 없는 세미콜론을 추가했다. 세미콜론은 하나의 구문을 완결짓는다. 그러므로 여기서는 널 구문(null statement), 즉 세미콜론 앞에 아무것도 없는 구문이 while 루프의 몸체가 된다. 블록 내에 있는 구문들은 루프가 끝난 귀에야 실행이 되겠지만, 널 구문 대문에 루프가 무한 루프에 빠져 버리므로 결코 블록 안에 도달할 수 없다. 그러므로 세미콜론을 붙일 때에는 항상 주의하여야 한다.
___
## 276p) 데이터형의 대용 이름
> C++에서는 특정 데이터형의 대응 이름을 만드는 방식이 두 가지가 있다. 첫 번째 방법은 전처리기를 사용하는 것이다.
> <pre><code>#define BYTE char              // 전처리기가 BYTE를 char로 대체한다</code></pre>
> 이렇게 하면 프로그램을 컴파일할 때 전처리기가 BYTE라는 단어가 나타날 때마다 char로 대체한다. 따라서 BYTE는 char의 대용 이름이 된다.  
> 두 번째 방법은 C++(그리고 C)의 키워드인 typedef를 사용하여 데이터형의 대용 이름을 만드는 것이다. 예를 들어, char의 대용 이름으로 byte를 사용하고 싶으면 다음과 같이 사용한다.
> <pre><code>typedef char byte;             // byte를 char의 대용 이름으로 만든다</code></pre>
> 다음은 그것의 일반적인 형태이다.
> <pre><code>typedef typeName aliasName;</code></pre>
> aliasName을 어떤 데이터형의 대용 이름으로 만들려면 aliasName을 그 데이터형의 변수처럼 선언하고 그 선언 앞에 typedef 키워드를 붙인다. 예를 들어, byte_pointer를 char형을 지시하는 초인터의 대용 이름으로 만들려면, byte_pointer를 char형을 지시하는 포인터로 선언하고 typedef 키워드를 붙일 수 있다.
> <pre><code>typedef char * byte_pointer;   // char형을 지시하는 포인터</code></pre>
> #define을 비슷한 용도로 사용할 수도 있지만, 이것은 여러 개의 변수 리스트를 선언하는 경우에는 원하는 결과를 얻을 수 없다. 예를 들어 보자.
> <pre><code>#define FLOAT_POINTER float *
> FLOAT_POINTER pa, pb;</code></pre>
> 전처리기는 이 선언을 다음과 같이 변환한다.
> <pre><code>float * pa, pb;        // pa는 float형을 지시하는 포인터, pb는 float형</code></pre>
> typedef를 사용하면 이런 문제가 발생하지 않는다. 복잡한 데이터형을 대용 이름으로 처리할 수 있기 때문에 typedef을 사용하는 것이 #define보다 훨씬 좋은 선택이다. 그리고 때로는 그것이 유일한 선택이다. typedef는 새로운 데이터형을 만드는 것이 아니라, 이미 존재하는 데이터형을 새로운 대용 이름으로 바꾸는 것이다. 따라서 word를 int형의 대룔 이름으로 만들었다면, cout은 word형의 값을 int형으로 처리할 것이다.
___
## 279p) 실전 프로그래밍 : 색다른 모양의 for 루프
> 그리 흔한 일은 아니지만, 간혹 다음과 같이 작성된 코드를 만날 수 있다.
> <pre><code>int I = 0;
> for(;;)                       // 이런 루프를 forever 루프라고 부른다
> {
>     I++;
>     // do something ...
>     if (30 >= I) break;       // if 구문과 break (6장)
> }</code></pre>
> 또는
> <pre><code>int I = 0;
> for(;;I++)
> {
>     if (30 >= I) break;
>         // do something ...
> }</code></pre>
> 이와 같은 코드는 for 루프를 조건 검사 표현식이 비어 있으면 true로 처리된다는 사실에 기초를 두고 있다. 이러한 예제는 이해하기가 쉽지 않다. 그리고 루프를 작성할 때 사용하는 일반적인 루프 모형도 아니다. 첫 번째 예제는 다음과 같이 do while 루프를 사용하여 좀더 명확하게 나타낼 수 있다. 
> <pre><code>int I = 0;
> do {
>     I++;
>     // do something ...
> while (30 < I);</code></pre>
> 두 번째 예제도 다음과 같이 while 루프를 사용하여 좀 더 명확하게 나타낼 수 있다.
> <pre><code>while (I < 30)
> {
>     // do something ...
>     I++;
> }</code></pre>
> 일반적으로 코드를 명확하고 쉽게 작성하는 것이 색다른 형식으로 코드를 작성할 수 있는 자신의 능력을 자랑하는 것보다 월씬 중요하다.
___
## 287p)
> 어떤 C++시스템은 키보드로 입력하는 시뮬레이션 EOF를 지원하지 않는다. 또 다른 시스템들은 그것을 불완전하게 지원한다. 화면의 메시지를 다 읽을 때까지 화면을 고정시킬 목적으로 cin.get()을 사용하고 있다면, EOF를 탐지했을 대 cin.get()이 더 이상 읽기 시도를 하지 않을 것이기 때문에 제대로 동작하지 않는다. 따라서 잠시 동안 화면을 고정시켜두는 것이 목적이라면 Listing 5.14에서 사용한 것과 같은 시간 지연 루프를 사용할 수 있다.
___
## 290p)
> 원래 put() 멤버는 함수 원형 put(char)만 가지고 있었다. 이것에 매개변수로 int형을 전달하여 char형으로 변환할 수 있었다. 표준도 하나의 원형을 요구한다. 그러나 현재 많은 C++들이 put(char), put(signed char), put(unsigned char) 세 가지 원형을 제공한다. 이러한 C++에서 put()에 int형 매개변수를 사용하면 에러가 발생한다. 그 이유는 int형을 변환할 때 선택할 수 있는 것이 한 가지 이상이기 때문이다. int형에 대해서는 cin.put(char(ch))와 같이 명시적 데이터형 변환이 필요하다.
___
## 292p)
> 어떤 C++ 시스템은 키보드로 EOF를 시뮬레이션하는것을지원하지 않거나, 불완전하게 지원한다. 그러한 시스템에서는 예제 Listing5.19가 설명한 대로 실행되지 않을 수도 있다. 화면의 메시지를 다 읽을 때까지 화면을 고정시킬 목적으로 cin.get()을 사용하고 있다면, EOF를 탐지했을 때 cin.get()이 더 이상 읽기 시도를 하지 않을 것이기 때문에 제대로 동작하지 않는다. 따라서 잠시 동안 화면을 고정시켜두는 것이 목적이라면 Listing 5.14에서 사용한 것과 같은 시간 지연 루프를 사용할 수 있다. 또는, cin.claer()를 사용할 수 있으며, 17장에서 자세히 설명할 것이다.
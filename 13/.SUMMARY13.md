상속은, 기존의 클래스(기초 클래스)로부터 새로운 클래스(파생 클래스)를 정의할 수 있게 함으로써, 프로그래밍 코드를 사용자의 특별한 요구에 대응할 수 있게 해 준다. ```public 상속```은 ```is-a 관계```를 나타낸다. 이것은 파생 클래스 객체가 기초 클래스 객체의 한 종류라는 것을 의미한다.

is-a 모델에서, 파생 클래스는 기초 클래스의 데이터 멤버들과 대부분의 메서드들을 상속한다. 그러나 파생 클래스는 기초 클래스 생성자, 파괴자, 대입 연산자는 상속하지 않는다. 파생 클래스는 기초 클래스의 public 멤버와 protected 멤버에 직접 접근할 수 있다. 그리고 기초 클래스의 private 멤버에는 기초 클래스의 public 메서드와 protected 메서드를 통해서만 접근할 수 있다. 파생 클래스 파괴자를 먼저 호출하고 나서 기초 클래스 파괴자를 호출한다.

그리고 그 파생 클래스를 계속되는 프로그램 개발에서 기초 클래스로 사용할 수 있다. 각각의 파생 클래스는 자신만의 생성자가 필요하다. 프로그램이 파생 클래스 객체를 생성할 때, 프로그램은 기초 클래스 생성자를 먼저 호출하고 나서 파생 클래스 생성자를 호출한다. 객체를 파괴할 때에는, 파생 클래스 파괴자를 먼저 호출하고 나서 기초 클래스 파괴자를 호출한다.

어떤 클래스를 기초 클래스로 만들 때, 파생 클래스가 상속된 멤버들에 직접 접근할 수 있도록 private 멤버 대신에 protected 멤버를 사용할 수 있다. 그러나 일반적으로 private 멤버를 사용하는 것이 프로그래밍 에러의 소지를 줄인다. 파생 클래스에서 기초 클래스 메서드를 다시 정의하는 것을 허용하려면, 기초 클래스에서 그 메서드의 앞에 키워드 ```virtual```을 붙여 가상 함수로 선언해야 한다. 이렇게 하면, 참조나 포인터에 의해 접근되는 객체를, 참조형이나 포인터형에 기초하지 않고 객체형에 기초하여 다룰 수 있다. 특히 기초 클래스의 파괴자는 일반적으로 가상이어야 한다.

구현 문제를 배제시킨 채 인터페이스를 정의하는 ```ABC(추상화 기초 클래스)```를 정의할 수 있다. 예를 들어, Circle이나 Square와 같은 특별한 도형 클래스들을 파생시킬 수 있는 Shape이라는 추상화 기초 클래스를 정의할 수 있다. 추상화 기초 클래스는 적어도 하나의 순수 가상 메서드를 가져야 한다. 선언할 때 마지막의 세미콜론 앞에 ```= 0```을 넣으면 그것은 순순 가상 메서드가 된다. 
<pre><code>virtual double area() const = 0</code></pre>

순수 가상 메서드들을 정의할 필요는 없다. 순수 가상 메서드를 멤버로 가지는 클래스의 객체는 생성할 수 없다. 순수 가상 메서드들은 파생 클래스들이 공통으로 사용하는 인터페이스를 정의하는 역할만 한다.
## 903p) 
> 파생 클래스의 객체를 생성할 때, 프로그램은 먼저 기초 클래스 생성자를 호출하고, 그 다음에 파생 클래스 생성자를 호출한다. 상속받은 데이터 멤버들을 초기화하는 일은 기초 클래스 생성자가 맡는다. ```멤버 초기자 리스트```를 사용하여 어떤 기초 클래스 생성자를 사용할 것인지를 나타낼 수 있다. 멤버 초기자 리스트를 생략하면, 디폴트 기초 클래스 생성자가 사용된다.  
>파생 클래스의 객체가 수명이 다했을 때, 프로그램은 먼저 파생 클래스 파괴자를 호출하고, 그 다음에 기초 클래스 파괴자를 호출한다.
___
## 903p) 멤버 초기자 리스트
> 파생 클래스 생성자는, 기초 클래스 생성자에 값들을 전달하기 위해 멤버 초기자 리스트 문법을 사용할 수 있다.  
> 다음과 같은 예를 생각해 보자.
> <pre><code>derived::derived(<i>type1</i> x, <i>type2</i> y) : base(x, y)      // 초기자 리스트
> {
> ...
> }</code></pre>
> 여기서, derived는 파생 클래스이고, base는 기초 클래스이다. x와 y는 기초 클래스 생성자가 사용하는 변수들이다.  
> 예를 들어, 파생 클래스 생성자가 10과 12를 매개변수로 받는다면, 멤버 초기자 리스트 문법을 통해서 이 데이터형의 매개변수들을 필요로 하는 기초 클래스 생성자에 10과 12가 전달된다.  
> 가상 기초 클래스(14장, "C++ 코드의 재활용" 참조)의 경우를 제외하고, 파생 클래스는 인접한 직계 상위 기초 클래스에만 값을 다시 전달할 수 있다. 동일한 방법으로 그 기초 클래스는 자신의 인접한 직계 상위 기초 클래스에 다시 그 정보를 전달할 수 있다. 멤버 초기자 리스트에 기초 클래스 생성자를 제공하지 않는다면, 프로그램은 디폴트 기초 클래스 생성자를 사용한다. 멤버 초기자 리스트는 생성자에만 사용할 수 있다.
___
## 917p)
> 기초 클래스 메서드를 파생 클래스에서 다시 정의할 대에는, 일반적으로 그 기초 클래스 메서드를 가상으로 선언한다. 이렇게 하면, 프로그램은 참조형이나 포인터형이 아니라 객체형에 기초하여 메서드 버전을 선택한다. 일반적으로 그러한 경우에는 기초 클래스에 가상 파괴자를 선언한다.
___
## 24p) 프로그램 조정
> 이 책의 예제들을 독자의 컴퓨터에서 실행하기 위해 예제들을 수정해야 하는 경우가 있을 것이다. 이러한 경우는 대부분 프로그램 환경이 원인일 수 있다. 1장에서 언급했듯이 아래 라인이 추가되면 키를 입력하기 전까지 화면을 열린 상태로 유지한다.
> <pre><code> cin.get(); </code></pre>
> 어떤 프로그램들은 키를 입력할 때까지 화면을 유지하기 위해서는 위 라인을 2번 입력해야할 수도 있다. cin.get()에 대해서는 4장에서 자세히 살펴보도록 하겠다.  
> 만일, 독자가 오래된 시스템을 사용하고 있다면 C++98 표준을 지원하지 않을 가능성이 있다. 일부 프로그램은 C++11 표준을 지원하는 컴파일러가 필요할 수도 있다. 가능하다면, 최대한 이 부분을 명확하게 구분해서 C++11을 지원하지 않는 경우의 대안을 제시하도록 할 것이다.
___
## 26p) 구문과 세미콜론
> 구문은 컴퓨터에게 내리는 하나의 완전한 지시를 말한다. 사용자가 작성한 소스 코드 파일을 컴파일러가 컴파일하려면, 어떤 구문이 언제 끝나고 다른 구문이 언제 시작하는지를 알 필요가 있다. 이를 위해 일부 언어에서는 ```구문 분리자(statement separator)```라는 것을 사용한다.  
> 예를 들어, FORTRAN에서는 한 구문과 다음 구문을 분리하기 위해 그 행의 끝을 사용한다 Pascal에서는 이를 위해 세미콜론을 사용한다. 그러니 Pascal에서는 약간의 예외를 인정한다.  
> 즉, END 바로 앞에 있는 구문처럼 구문을 굳이 분리할 필요가 없는 경우에는 세미콜론을 생략할 수 있다.  
> 그러나 C와 C++에서는 세미콜론을 분리자가 아니라 ```종결자(terminator)```로 사용한다. 종결자 역할을 하는 세미콜론은 구문과 분리하는 마커가 아니라 구문의 일부라는 것이 다르다. 그러므로 구문의 끝에 있는 세미콜론을 절대로 빠뜨리면 안 된다.
___
## 30p) C 스타일의 주석문
> C++는 /*와 */로 둘러싸인 C 스타일의 주석문도 인식할 수 있다.
> <pre><code>#incldue <iostream>   /* C 스타일 주석문 */ </code></pre> 
> C 스타일의 주석문은 행의 끝이 아니라 */에 의해 끝난다. 따라서 주석문이 여러 행을 차지할 수도 있다. 독자는 C++ 스타일의 주석문과 C 스타일의 주석문 중에서 어느 한쪽만을 사용하거나 둘 다 사용할 수 있다. 그러나 C++ 스타일은 주석문의 시작과 끝을 짝맟추는 데 신경쓰지 않아도 되므로 C 스타일의 주석문보다 문제를 덜 일으킨다.  
> 게다가, C99도 // 주석문을 C 언어에 추가하였다. 따라서 앞으로는 C++ 스타일의 주석문만을 사용할 것을 권장한다.
___
## 31p) 
> 프로그램에서 입력과 출력을 위해 cin과 cout을 사용하려면 iostream 파일을 포함시켜야 한다.
___
## 35p~36p) 연산자 오버로딩
> 독자가 C에서 C++로 건너오는 중이라면, ```삽입 연산자(<<)```가 왼쪽-시프트 비트 연산자와 모양이 같은 것을 눈치챘을 것이다. 이것이 바로 ```연산자 오버로딩(operator overloading)```의 한 예다. 연산자 오버로딩에 의해 동일한 연산자 기호가 여러 가지 의미를 가질 수 있다. 컴파일러가 전후 관계를 파악하여 그 연산자가 어떤 의미로 사용된 것인지 결정한다. C 언어도 약간의 연산자 오버로딩 기능을 가지고 있다.  
> 예를 들어 & 기호는 주소 연산자와 AND 비트 연산자로 모두 사용된다. 여기서는 이 연산자들이 무슨 기능을 하느냐가 중요한 것이 아니라, **동일한 연산자가 여러 의미로 사용될 수 있다는 사실**과, **컴파일러가 전후 관계를 파악하여 연산자의 의미를 결정한다는 사실**이 중요하다. (일상 언어에서도 같은 단어에 여어 의미를 실어 쓰는 경우가 많다.  
> 예를 들어, "오늘 새 구두를 샀다"와 " 구두로 한 약속은 법적 구족력이 없다"라는 말에서 '구두'라는 단어의 의미는 문맥의 전후 관계를 파악하여 판단하게 된다.) C++는 이와 같은 연산자 오버로딩 기능을 더욱 확장하여 사용자가 정의하는 데이터형인 클래스에 대해서도 의미를 오버로딩한다.
___
## 42p) 변수를 선언하는 이유
> BASIC과 같은 언어에서는 변수를 따로 선언할 필요 없이 새로운 이름을 사용할 때마다 변수들이 자동으로 생성된다. 이것은 프로그래머에게 친절을 베푸는 것일 수도 있으나, 변수 이름을 잘못 입력하면 자기도 모르는 사이에 엉뚱한 변수가 생성될 수 있다.  
> 다음과 같은 BASIC프로그램을 살펴보자
> <pre><code>CastleDark = 34
> ...
> CastleDank = CastleDark + MoreGhosts
> ... 
> PRINT CastleDark </code></pre>
> 여기서 CastleDank는 CastleDark를 잘못 입력한 것이므로 CastleDark의 값은 변경되지 않을 것이다. 이러한 실수는 BASIC의 프로그래밍 규칙을 위반하는 것이 아니기 때문에 찾아내기가 어렵다. 그러나 C++에서 CastleDark는 선언한 것이고, 철자를 잘못 입력한 CastleDank는 선언하지 않은 것이다.  
> 그러므로 C++에서 코드를 이와 같이 작성했다면, 선언하지 않은 변수를 사용한 셈이기 때문에 규칙을 위반하는 것이다. 따라서 C++컴파일러가 에러를 찾아내 잠재적인 버그의 소지를 없앤다.
___
## 45p) cout과 printf()
> 독자가 C 언어와 printf()에 익숙하다면, ```cout```이 다소 생소하게 여겨질 것이다. 그래서 이미 손에 익은 printf()에 자꾸 애착이 갈지도 모르겠다.  
> 그러나 cout은 `%d`나 `%s`와 같은 변환 지정자들을 반드시 사용해야 하는 ```prinft()```보다 훨씬 간단하며 뛰어난 장점을 가지고 있다. 게다가 cout은 여러 가지 데이터형을 스스로 판단할 수 있고, 생김새가 단순하며, 또한 사용자 정의 데이터형을 인식할 수 있도록 기능을 확작할 수 있다.  
> 독자가 printf()를 좋아하는 이유가 정교한 출력 제어가 가능하기 때문이라면, cout으로도 그와 동일한 효과를 낼 수 있으므로 안심해도 좋다. (17장, "입력, 출력, 파일"을 보라)
___
## 46p) 프로그램 조정 작업
> 기존의 소스코드에서 cin.get() 명령어를 추가해야 한다면, 모니터에 화면을 출력하기 위해서는 cin.get()을 두 번 호출해 주어야 할 것이다.  
> 첫 번째는 Enter 키나 리턴키를 눌렀을 때 입력받은 라인이고, 두 번째는 Enter 키나 리턴키를 다시 누를 때까지 프로그램이 대기하는 것이다. 
___
## 49p)
> 클래스는 데이터 형식의 모든 속성을 서술한 것이고, 객체는 그 서술에 따라 실제로 생성된 구체물이다.
___
## 52p)
> C++ 프로그램은 프로그램 안에서 사용할 모든 함수의 원형을 가지고 있어야 한다.
___
## 54p) 라이브러리 함수의 사용
> C++의 라이브러리 함수들은 라이브러리 파일에 들어 있다. 컴파일러는 프로그램을 컴파일할 때 라이브러리 함수들이 들어 있는 라이브러리 파일을 찾는다.  
> 그런데 컴파일러마다 자동으로 찾는 라이브러리 파일들이 다르다. [Listing 2.4](https://github.com/tlsehddbs/CPP_Basic/blob/main/02/04sqrt.cpp "Listing 2.4")를 컴파일시켰을 때 '_sqrt is an undefined external'이라는 (피해야 할 상황처럼 보이는) 메시지가 나온다면, 컴파일러가 cmath를 찾지 못하고 있는 것이다. (대부분의 컴파일러가 프로그램을 컴파일할 때 함수 이름 앞에 밑줄 문자를 붙인다.) 이때에는 컴파일러 사용 설명서를 잘 읽고, 컴파일러가 라이브러리 파일을 제대로 찾을 수 있도록 해 주어야 한다.  
> 예를 들어, Unix에서 운영되는 C++에서는 -lm(library math라는 뜻)옵션을 끝에 덧붙여 주어야 한다.
> <pre><code>CC sqrt.c - lm</code></pre>
> Linux에서 돌아가는 Gnu 컴파일러의 사용법도 이와 비슷하다.
> <pre><code>g++ sqrt.c - lm</code></pre>
> 프로그램에 cmath 헤더 파일을 포함시키는 것은 컴파일러에게 함수 원형만을 알려 주는 것일 뿐, 컴파일러가 올바른 라이브러리 파일을 찾을 수 있도록 해 주는 것은 아니다.
___
## 60p) 키워드
> ```키워드```는 컴퓨터 프로그래밍 언어가 사용하는 단어이다. 이 장에서는 int, void, return, double이라는 네 개의 C++ 키워드를 사용했다. 키워드들은 C++에서 용도가 따로 정해져 잇으므로 다른 용도로는 사용할 수 없다.  
> 즉, return을 변수 이름으로 사용할 수 없고, double을 함수 이름으로 사용할 수 없다.  
> 그러나 painter(int가 안에 숨어 있다) 또는 return_aces와 같이 키워드를 어떤 이름의 일부분으로 사용하는 것은 괜찮다. 부록 B, "C++ 예약어"에 C++에서 사용하는 모든 키워드들을 정리해 두었다.  
> main은 C++ 언어의 함수의 이름일 뿐이다. 따라서 main을 변수 이름으로 사용할 수는 있다.그러나 여기에서 설명하기 어려운 어떤 상황에서 그것이 문제를 일으킬 수도 있고, 프로그래머에게도 혼동을 주므로 사용하지 않는 것이 좋다. 마찬가지로 다른 함수 이름이나 객체 이름들도 키워드가 아니다. 하나의 프로그램에서 객체 이름과 변수 이름이 같으면, 컴파일러가 혼동을 일으킨다.  
> 예를 들어, 출력을 위해 cout 객체를 사용하지 않는 어떤 함수에서 cout을 변수이름으로 사용할 수는 있다. 그러나 cout 객체를 사용하는 함수에서 cout이라는 변수를 함께 사용할 수는 없다.
___
## 64p) 실전 프로그래밍 : 이름짓기의 관례
> C++ 프로그래머들은 함수, 클래스, 변수의 이름을 지을 때, 그것이 축복인지 저주인지 모를 정도로 선택의 여지가 넓다. 프로그래머들은 이름을 짓는 스타일에 대해 다양하고도 강력한 자신의 의견을 가지고 있다.  
> 이 문제는 공개 포럼 석상에서 자주 논쟁을 일으킨다. 함수 이름을 하나 예로 든다면, 프로그래머는 다음 중에서 자신이 원하는 스타일을 선택할 수 있다.  
> MyFunction()  
> myfunction()  
> myFunction()  
> my_function()  
> my_funct()  
> 어떤 스타일의 이름을 사용하느냐는 프로그램 개발팀, 사용하는 기술과 라이브러리의 특성, 프로그래머 개인의 기호에 달려 있다. 그리고 C++ 언어에 적법하기만 하면 모든 스타일이 허용되므로 안심해도 좋다. 따라서 스스토 판단하여 원하는 스타일을 사용할 수 있다.<br> 그러나 언어가 모든 스타일을 허용하는 것과는 별개의 문제로서, 일관성과 정확성을 위해 개인적인 이름짓기 스타일을 정하여 한결같이 지키는 것이 바람직하다. 정확하고 쉽게 알아볼 수 있도록 이름을 직는 것이 관례이다. 이 관례를 따르는 것이 좋은 소프트웨어를 개발하는 지름길이다. 또한 그것은 독자의 프로그래밍 인생에 전반벅으로 도움을 줄 것이다.  
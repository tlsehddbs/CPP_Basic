## 74p) 실전 프로그래밍 : 변수 이름
> 함수 이름을 짓는 것과 마찬가지로, 변수 이름을 짓는 것도 어떤 논쟁을 일으킬 만한 토대를 제공한다. 실제로 이 주제가 프로그래머들 간에 가장 심한 의견 불일치를 만들어 내고 있다. 함수 이름과 마찬가지로, C++ 컴파일러는 적법하기만 하면 사용자가 변수 이름을 어떻게 짓든 전혀 상관하지 않는다. 그렇지만 일관되고 정확한 개인적인 스타일을 정하고, 이를 따르는 것이 여러 모로 도움이 될 것이다.  
> 함수 이름짓기와 마찬가지로, 변수 이름짓기에서도 대문자 표시 문제가 가장 큰 논쟁거리이다. (2장 "C++ 시작하기"에 나와 있는 "실전 프로그래밍 : 이름짓기의 관례"를 보라.) 그러나 많은 프로그래머들이 변수의 내용이나 데이터형을 알려 주는 접두어를 변수 이름에 붙인다. 예를 들면, 정수형 변수 myWeight를 nMyWeight라고 이름지을 수 있다. 여기서 n은그 값이 정수하는 것을 나타낸다. 이런 식으로 이름을 지으면 변수 정의를 파알하기 어려운 코드를 읽을 대 유용하다. 또한 이 변수를 intMyWeight라고 이름지을 수도 있다. 나중 것이 글자 수가 더 많기는 하지만(프로그래머들은 글자 수가 많은 것을 싫어한다) 더 정확하고 알아보기 쉬울 것이다. C++에서는 이와 같은 용도로 여러 가지 접두어들이사용되고 있다. str이나 sz는 널(null)로 끝나는 문자열을 나타내고, b는 불 값을, p는 포인터를, c는 단일 문자를 나타내는 데 사용할 수 있다.   
> C++의 세계로 더 깊이 들어가면, (m_lpctstr과 같이 다소 복잡한 접두어를 포함하여) 접두어를 붙인 이름들을 수없이 보게 될 것이다. m_lpctstr은 널로 끝나는 문자열 상수를 지시하는 long 포인터가 들어 있는 클래스 멤버의 값이다. 이 정도는 약과이다. 무슨 듯인지 도무지 이해할 수 없는 이상한 이름들도 많다. 드러나 뭐니뭐니 해도 일관성과 정확성을 갖추는 것이 최선이다. 사용자 자신의 필요와 선호도, 개인적인 스타일에 따라 변수 이름을 지으면 된다. (그렇지 않다면 프로그래머가 근무하는 회사는 회사의 필요와 선호도, 회사 스타일에 맞추어 변수 이름을 지으면 된다.)
___
## 75p) 비트와 바이트
> 컴퓨터의 메모리를 구성하는 기본 단위는 비트이다. 비트의 개념은 켜거나 끌 수 있는 전기 스위치를 연상하면 쉽게 이해할 수 있다. 이를테면 전기 스위치가 꺼진 상태는 값 0을 나타내고, 켜진 상태는 값 1을 나타낸다. 8비트 폭의 메모리는 256가지의 조합을 만들 수 있다. 256이라는 수는, 하나의 비트가 두 가지 경우를 설정할 수 있으므로 8비트이면 2X2X2X2X2X2X2X2=256가지의 경우를 설정할 수 있다는 데에서 나온 것이다. 따라서 8비트 ㅗㄱ의 메모리로 0부터 255까지 또는 -128에서 127까지의 값을 나타낼 수 있다. 비트 하나가 추가될 때마다 비트 조합의 수는 두 배가 되므로 16비트는 65,536개의 값을, 32비트는 4,294,967,296개의 값을 나타낼 수 있다.  
> 일반적으로 바이트는 8비트의 메모리 단위를 의미한다. 바이트 단위로 컴퓨터의 메모리 크기를 나타낼 때, 1킬로바이트는 1024바이트 이고 1메가바이트는 1024킬로바이트이다. 그러나 C++는 바이트를 이와는 조금 다르게 정의한다. C++에서 바이트는 컴파일러의 기본 문자 세트를 수용할 수 있는 최소한의 연속된 비트들로 구성된다. 즉, 바이트를 구성하는 비트들의 조합으로 나타낼 수 있는 값의 수가, 컴파일러가 사용할 수 있는 문자 수와 같거나 그보다 커야 한다. 미국의 경우에, 기본 문자 세트는 대게 ASCII와 EBCDIC이다. 이들은 모두 8비트로 나타낼 수 있으므로, 이들 문자 세트를 사용하는 시스템에서 C++의 바이트는 8비트이다. 그러나 국제적으로 사용되는 프로그램을 개발하려면 Unicode와 같이 더 큰 문자 세트가 필요하다. 이와 같이 더 큰 문자 세트를 사용하는 시스템에서는 C++의 바이트가 16비트 또는 32비트이다. 종종 8자리수를 나타내기 위하여 'octet' 용어를 사용하기도 한다.
___
## 78p)
> 만약 본인의 시스템이 long long 형태를 지원하지 않을 시엔 시행문에서 제거해야 한다.
___
## 79p~80p) 기호 상수와 전처리기
> climits 헤더 파일에는 아래와 비슷한 행들이 정의되어 있다.
> <pre><code>#define INT_MAX 32767</code></pre>
> C++의 컴파일 과정을 다시 상기해 보가. 먼저 소스 코드를 전처리기로 보낸다. 여기서 #define은 #include와 같은 전처리 지시자이다. 이 지시자는 소스 코드를 검색하여 INT_MAX가 나올 때마다 32767로 대체하라고 전처리기에 지시한다. 그러므로 #define 지시자는 에디터나 워드 프로세서에서 전체 파일을 대상으로 문자열 찾아 바꾸기(search and replace) 기능처럼 동작한다. 이렇게 해서 모든 INT_MAX가 32767로 대체된 소스 코드가 컴파일 과정으로 넘겨진다. 전처리는 독립 코튼에서만(분리된 단어에만) 적용되고 파묻힌 단어들은 건너뛴다. 즉, PINT_MAXIM이 P32767IM으로 대체되지 않는다.<br> #define 지시자는 사용자 스스로 기호 상수를 정의할 때에도 사용할 수 있다. (Listing 3.2를 보라.) 그러나 #define 지시자는 C의 유물이다. C++에서는 기호 상수를 만드는 더 좋은 방법을 제공한다. (그것은 const 키워드를 사용하는 것이다. 이에 대해서는 잠시 후에 설명한다.) 따라서 이 책에서는 #define을 많이 사용하지 않는다. 그러나 일부 헤더 파일들, 특히 C와 C++에서 공통으로 사용하는 헤더 파일들은 이 지시자를 그대로 사용한다.
___
## 98p~99p) Unicode와 ISO 10646
> 유니코드(Unicode)는 수많은 문자와 기호의 표준 코드를 데이터형별로 묶어 제공함으로써 다양한 문자 세트를 표시할 수 있도록 해 준다. 예를 들어, 유니코드에는 ASCII 코드도 들어있어 A나 Z와 같은 미국 라틴 문자는 ASCII 시스템에서나 유니코드 시스템에서나 똑같이 표현된다. 유니코드는 유럽어에서 사용되는 다른 라틴 문자들: 그리스어, 키릴어, 히브리어, 아랍어, 타이어, 뱅갈어와 같은 다른 문자들; 중국어나 일본어에서 사용되는 표의문자도 포함하고 있다. 현재 유니코드는 96,000개 이상의 기호와 49개의 그크립트를 표현하고 있으며, 아직도 개발이 진행중이다. 이에 대해 자세히 알려면 유니코드 콘소시엄의 웹 사이트 www.unicode.org 에 접속해 보라.  
> 유니코드는 각각의 character에 code point라고 불리는 번호를 대입한다. 전형적인 유니코드의 code point는 U-222B와 같은 형태를 취한다. 'U' 자는 유니코드 특성으로 인식하며, 이 경우에 222B는 이 특성에 대한 16진법을 의미하는 상수이다.  
> 국제표준화기구(ISO)는 다국어 텍스트를 처리하기 위한 국제 표준 코드인 ISO 10646을 개발하는 실행위원회를 개설하였다. ISO 19646 실행위원회와 Unicode 실행위원회는 자신들이 개발한 표준을 서로 조율하기 위하여 1991년부터 함께 협력하고 있다. 
___
## 105p)
>d.dddE+n 형식은 소수점을 오른쪽으로 n 자리만큼 이동하는 것이고, d.dddE-n은 소수점을 왼쪽으로 n 자리만큼 이동하는 것이다. 이러한 자리 이동의 근본 개념은 "부동 소수점"에서 기인한다.
___
## 108p) 실전 프로글밍 : 헤더 파일 들여다보기
> C++ 소스 코드의 맨 앞에 나오는 파일 포함 전처리 지시자들은 헤더 파일을 마술처럼 보이게 만들기 쉽상이다. C++ 새내기 프로그래머들은 어떤 헤더 파일이 어떤 기능을 하는 것인지 책을 읽어 가면서 조금씩 경험하고 배우게 된다. 그리고는 프로그램이 잘 동작하도록 해주는 용도로만 그 헤더 파일들을 포함시킨다. 헤더 파일들은 절대로 신비하고 비밀스런 지식이 아니다. 마음 푹 놓고 헤더 파일들을 열어서 그 속을 들여다보라. 그것들은 모두 텍스트 파일이므로 쉽게 읽을 수 있다. 프로그램에 포함시키는 헤더 파일들은 모두 사용자의 컴퓨터에 또는 사용자의 컴퓨터가 접근할 수 있는 장소에 들어 있다. 독자가 프로그램에 포함시켜 사용하는 헤더 파일들을 찾아서 그 안에 무엇이 들어 있는지 살펴보라. 대부분의 경우에, 헤더 파일들이 유용한 지식과 정보의 원천이라는 사실을 금방 알게 될 것이다. 개발하는 애플리케이션에 좀 더 복잡한 헤더 파일들을 초함시키고, 표준이 아닌 라이브러리를 사용하게 될 때, 레더 파일을 들여다보는 이러한 습관이 매우 큰 도움을 줄 것이다.
___
## 110p) 데이터형의 분류
> C++는 기본 데이터형을 몇 가지 계열로 분류하여 부르고 있가. signed char, short, int, long형은 signed 정수형이라 부른다. 이들의 unsigned 버전을 unsigned 버전을 unsigned 정수형이라 부른다. bool, char, wcaht_t, signed 정수형, unsigned 정수형을 통틀어 정수형(integer type)이라 부른다. C++11에서는 이러한 정수형 리스트에 char16_t와 char32_t가 추가되었다. float, double, long double형은 부동 소수점형(floating_point type)이라고 부른다.정수형과 부동 소수점형을 합쳐서 말할 때에는 산술형(arithmetic type)이라고 부른다.
___
## 115p) 연산자 오버로딩 맛보기
> Listing 3.11에서 나눗셈 연산자는 세 가지 서로 다른 연산, 즉 int 나눗셈, float 나눗셈, double 나눗셈을 수행한다. C++는 문맥을 파악하며(이 경우에는 피연산자의 데이터형을 파악하여) 어느 연산을 수행할 것인지를 결정한다. 이와 같이 동일한 연산자가 서로 다른 연산에 사용되는 것을 연산자 오버로딩(operator overloading)이라 한다. C++는 연산자 오버로딩의 예를 몇 가지 내장하고 있다. 연산자 오버로딩의 개념은 사용자가 정의하는 클래스에까지 확잘할 수 있다. 오버로딩은 객체 지향 프로그래밍의 중요한 특성이다.
## 381p) C++와 ANSI C의 함수 원형 비교
> ANSI C는 C++로부터 함수 원형의 개념을 차용했다. 그러나 두 언어의 함수 원형 간에는 약간의 차이가 있다. 가장 큰 차이는, ANSI C는 클래식 C언어와 호환성을 유지하기 위해 함수 원형의 사용이 선ㅌ개적이지만, C++는 함수 원형을 필수적으로 사용해야 한다는 점이다. 예를 들어, 다음과 같은 함수 선언이 있다고 가정해 보자
> <pre><code>void say_hi();</code></pre>
> C++에서는 괄호 안을 비워 놓아도 그 안에 void라는 키워드가 들어 있다고 간주한다. 이것은 그 함수가 어떠한 매개변수도 요구하지 않는다는 것을 의미한다. 그러나 ANSI C에서 괄호 안을 비워 놓은 것은 매개변수가 무엇인지 밝히는 것을 거부한다는 뜻이다. 이 말은 매개변수 리스트가 무엇인지 확인하지 않겠다는 것이다. C++에서 이것을 나타내는 방법은 생략 부호(ellipsis)를 사용하는 것이다.
> <pre><code>void say_bye(...);     // C++에서 매개변수 리스트 확인 표기</code></pre>
> 일반적으로, 이와 같은 생략 부호의 사용은 preinft()와 같이 매개변수의 수가 가변적인 C함수와의 인터페이스에만 요구된다.
___
## 389p)
> 어떤 C++는 long double형을 지원하지 않는다. 그러한 경우에는 일반적인 double형을 사용한다.
___
##  397p)
> 배열을 처리하는 함수에게 배열의 종류와 원소의 개수를 알려 주려면, 두 개의 거로 독립된 매개변수를 정보로 넘겨주어야 한다.
> <pre><code>void fillArray(int arr[], int size);       // 함수 원형</code></pre>
> 배열의 크기를 대괄호 표기 형태를 사용하여 함수에 전달하면 안된다.
> <pre><code>void fillArray(int arr[size]);             // 안 된다</code></pre>
___
## 420p)
> 데이터형 자체가 포인터가 아니라면, const 데이터의 주소이든 const가 아닌 데이터의 주소이든 const를 지시하는 포인터에 모두 대입할 수 있다. 그러나 const가 아닌 데이터의 주소는 const가 아닌 포인터에만 대입할 수 있다.
___
## 411p) 가능하면 const를 사용하라
> 포인터 매개변수를 상수 데이터를 지시하는 포인터로 선언하는 이유는 두 가지이다.
> * 이것은 실수로 데이터를 변경기키는 프로그래밍 에러를 막을 수 있다.
> * const를 사용하는 함수는 const와 const가 아닌 매개변수를 모두 처리할 수 있지만, 함수 원형에서 const를 생략한 함수는 const가 아닌 데이터만 처리할 수 있다.
> 
> 따라서 가능하다면 형식 포인터 매개변수를 const를 지시하는 포인터로 선언해야 한다.
___
## 428p)
> 어떤 C++ 시스템은 새로운 const 헤더 파일 대신에 오래된 math.h를 사용한다. 어떤 컴파일러에서는 수학 라이브러리를 불러들이도록 사용자가 직접 컴파일러에게 지시해야 한다. 예를 들어, 구형 g++ 버전은 다음과 같은 명형행을 사용한다.
> <pre><code>g++ strctfun.c -lm</code></pre>
___
## 432p)
> 어떤 컴파일러에서는 math 라이브러리를 찾을 수 있도록 명시해야 한다. 예를 들면, 예전의 g++ 버전은 다음과 같은 구문을 사용한다.
> <pre><code>g++ structfun.c -lm</code></pre>
___
## 446p) 역사냐 논리냐
> 문법은 신성하다! pf와 (*pf)가 어떻게 동등할 수 있다는 말인가? 어떤 학파는 pf가 함수를 지시하는 포인터이므로 *pf가 함수이고, 따라서 (*pf) ()를 함수 호출로 사용해야 한다고 주장했다. 또 다른 학파는 함수 이름이 그 함수를 지시하는 포인터이므로, 그 함수를 지시하는 포인터도 함수 이름처럼 행동해야 당연하고, 따라서 pf()를 함수 호출로 사용해야 한다고 주장했다. C++는 두 가지 형태가 논리적으로 서로 일관되지는 않지만 모두 옳다 또는 모두 허용된다는 타협의 입장을 취했다. 그러한 타협이 거슬린다고 역정을 내기 전에, 논리적으로 일관성이 없는 견해들을 너그러이 수용할 수 있는 능력이 인간 지성의 위대함이라는 사실을 받아들이기 바란다.
___
## 454p) auto의 진가
> C++11의 목표 중의 하나가 C++을 보다 쉽게 사용하고, 프로그래머가 세부적인 것은 신경을 덜 쓰면서도 설계에 더 집중하 수 있도록 하는것이다. Listing 7.19는 이런 관점에서 설명을 한 것이다.
> <pre><code>auto pc = &pa;             // C++11 자동 형 변환
> const double *(*(*pc)[3])(const double *, int) = &pa;
>                            // C++98, 직접 복잡하게 선언해야 한다</code></pre>
> 자동 형 변환은 컴파일러의 임무에 대한 철학적 변화를 반영한 것이다. C++98에서 컴파일러는 프로그래머가 잘못을 항ㅆ을 때 알려 줘야 하는 지식에 중점을 두었다. C++11에서는 이것은 최소한으로 가져가면서, 프로그래머가 올바른 선언을 하는 데 도움을 줄 수 있는 지식에 중점을 두고 있다.  
> 여기에 잠재적 결점이 있다. 자동 형 변환은 초기화하는 형과 변수의 형을 매치시키는 것을 보장한다. 그러나, 초기화 시에 잘못된 형을 제공할 가능성이 여전히 존재한다.
> <pre><code>auto pc = *pa;         // 이런! *pa가 아니라 &pa를 사용해야 한다</code></pre>
> 이 선언은 pc를 *pa의 형과 매치를 시키고 컴파일러는 에러를 발생시킨다. 